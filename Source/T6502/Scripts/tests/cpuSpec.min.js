var Tests;(function(){describe("cpu",function(){function i(){n.poke(512,3),n.poke(513,0),n.poke(514,2)}var n,t,r;beforeEach(function(){module("app")}),beforeEach(function(){inject(function(i,u,f){t=i,r=u,n=new Emulator.Cpu(t,r,f)})}),afterEach(function(){n.stop()}),describe("given cpu when constructed",function(){it("then should set all default registers",function(){expect(n.rA).toBe(0),expect(n.rX).toBe(0),expect(n.rY).toBe(0),expect(n.rP).toBe(0),expect(n.rPC).toBe(Constants.Memory.DefaultStart),expect(n.rSP).toBe(Constants.Memory.Stack)}),it("then should reset all timer information",function(){expect(n.started).toBe(null),expect(n.elapsedMilliseconds).toBe(0),expect(n.instructionsPerSecond).toBe(0)}),it("then should reset running and error states",function(){expect(n.runningState).toBe(!1),expect(n.errorState).toBe(!1)}),it("then should log to the console",function(){expect(t.lines.length).toBe(1)})}),describe("given cpu that is running when stop called",function(){beforeEach(function(){i()}),it("then should set running state to false",function(){n.run();var t=!1;runs(function(){setTimeout(function(){n.stop(),t=!0},10)}),waitsFor(function(){return t},"Failed to stop the cpu.",1e3),runs(function(){expect(n.runningState).toBe(!1)})})}),describe("given cpu that is running when run called",function(){it("logs to the console that the cpu is already running",function(){var u,r;i(),u=t.lines.length,n.run(),r=t.lines.length,expect(r).toBe(u),n.run(),expect(t.lines.length).toBe(r+1),n.stop()})}),describe("given cpu in error state when run called",function(){it("logs to the console that the cpu cannot run",function(){var r=t.lines.length;i(),n.errorState=!0,n.run(),expect(t.lines.length).toBe(r+1),expect(n.runningState).toBe(!1)})}),describe("given cpu in valid state when run called",function(){beforeEach(function(){i(),n.run()}),afterEach(function(){n.stop()}),it("should set running state to true",function(){expect(n.runningState).toBe(!0)})}),describe("given cpu with stack available when stackPush called",function(){var t;beforeEach(function(){t=n.stackPush(128)}),it("should return true",function(){expect(t).toBe(!0)}),it("should update the stack pointer",function(){expect(n.rSP).toBe(255)})}),describe("given cpu with no stack available when stackPush called",function(){beforeEach(function(){n.rSP=-1}),it("should throw an exception",function(){expect(function(){n.stackPush(128)}).toThrow()})}),describe("given cpu with information on stack when stackPop called",function(){}),describe("given cpu with no information on stack when stackPop called",function(){}),describe("given cpu with address on stack when stackRts called",function(){}),describe("given cpu when addressPop called",function(){}),describe("given cpu when addressPopWord called",function(){}),describe("given cpu when poke called with invalid address",function(){}),describe("given cpu when poke called with valid address",function(){}),describe("given cpu when poke called with invalid value",function(){}),describe("given cpu when peek called with invalid address",function(){}),describe("given cpu when peek called with valid address",function(){}),describe("given value with negative bit set when setFlags called",function(){}),describe("given value with negative bit not set when setFlags called",function(){}),describe("given zero value when setFlags called",function(){}),describe("given non-zero value when setFlags called",function(){}),describe("given value without overflow when compareWithFlags called",function(){}),describe("given value with overflow when compareWithFlags called",function(){}),describe("given non-matching values when compareWithFlags called",function(){}),describe("given matching values when compareWithFlags called",function(){}),describe("given value greater than register when compareWithFlags called",function(){}),describe("given value less than reigster when compareWithFlags called",function(){}),describe("given op code value when getOperation called",function(){})})})(Tests||(Tests={}))