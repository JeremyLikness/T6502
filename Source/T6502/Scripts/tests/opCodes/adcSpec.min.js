var Tests;(function(){describe("ADC - Add with Carry",function(){var i,n,r,t;beforeEach(function(){module("app")}),beforeEach(function(){inject(function(t,u){i=t,r=u,n=i.getCpu()})}),describe("ADC Immediate",function(){beforeEach(function(){t=new Emulator.AddWithCarryImmediate,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!1)}),describe("given not decimal mode and no carry flag set",function(){beforeEach(function(){n.poke(n.rPC,70),n.rA=88,t.execute(n)}),it("then should add the numbers and keep carry flag clear",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(158)})}),describe("given not decimal mode and carry flag set",function(){beforeEach(function(){n.poke(n.rPC,70),n.rA=88,n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!0),t.execute(n)}),it("then should add the numbers and reset the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(159)})}),describe("given not decimal mode and addition results in carry",function(){beforeEach(function(){n.poke(n.rPC,254),n.rA=2,t.execute(n)}),it("then should add the numbers and set the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!0),expect(n.rA).toBe(256&Constants.Memory.ByteMask)})}),describe("given no unsigned carry but signed overflow",function(){beforeEach(function(){n.poke(n.rPC,80),n.rA=80,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!1),t.execute(n)}),it("then should add the numbers and set the overflow flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.OverflowFlagSet)).toBe(!0),expect(n.rA).toBe(160)})}),describe("given unsigned carry and signed overflow",function(){beforeEach(function(){n.poke(n.rPC,208),n.rA=144,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!1),t.execute(n)}),it("then should add the numbers and set the carry and set the overflow flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.OverflowFlagSet)).toBe(!0),expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!0),expect(n.rA).toBe(96)})}),describe("given decimal mode and no carry flag set",function(){beforeEach(function(){n.poke(n.rPC,34),n.rA=34,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!0),t.execute(n)}),it("then should add the numbers and keep the carry flag clear",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(68)})}),describe("given decimal mode and carry flag set",function(){beforeEach(function(){n.poke(n.rPC,34),n.rA=34,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!0),n.setFlag(Constants.ProcessorStatus.CarryFlagSet,!0),t.execute(n)}),it("then should add the numbers and reset the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!1),expect(n.rA).toBe(69)})}),describe("given decimal mode and addition that carries",function(){beforeEach(function(){n.poke(n.rPC,70),n.rA=88,n.setFlag(Constants.ProcessorStatus.DecimalFlagSet,!0),t.execute(n)}),it("then should add the numbers and set the carry flag",function(){expect(n.checkFlag(Constants.ProcessorStatus.CarryFlagSet)).toBe(!0),expect(n.rA).toBe(4)})})})})})(Tests||(Tests={}))